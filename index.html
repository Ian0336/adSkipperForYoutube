<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>YouTube Embed Proxy</title>
    <style>
      html, body { height: 100%; }
      * { box-sizing: border-box; }
      body { margin: 0; background: #000; }
      #playerWrapper, iframe { width: 100%; height: 100%; border: 0; display: block; }
      #message {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        color: #ffffff;
        text-align: center;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      }
      #message code { display: inline-block; background: #111; padding: 4px 8px; border-radius: 6px; }
      a { color: #4ea1ff; }
    </style>
  </head>
  <body>
    <div id="playerWrapper" style="display:none;"></div>

    <div id="message">
      <div>
        <h1 style="margin: 0 0 12px; font-size: 18px; font-weight: 600;">YouTube Embed Proxy</h1>
        <p style="margin: 0 0 8px; opacity: 0.85;">
          Provide a YouTube video ID in the path or query.
        </p>
        <p style="margin: 0 0 16px;">
          <code>/{videoId}</code> or <code>?v={videoId}</code>
        </p>
      </div>
    </div>

    <script>
      (function () {
        function getParam(name, search) {
          var params = new URLSearchParams(search || "");
          var value = params.get(name);
          return value && value.trim() ? value.trim() : null;
        }

        function looksLikeVideoId(str) {
          return /^[A-Za-z0-9_-]{6,}$/.test(str) && str.toLowerCase() !== "index.html";
        }

        function extractVideoId(loc) {
          var byV = getParam("v", loc.search);
          if (byV) return byV;
          var byVideoId = getParam("videoId", loc.search);
          if (byVideoId) return byVideoId;
          var segments = (loc.pathname || "").split("/").filter(Boolean);
          if (segments.length) {
            var candidate = segments[segments.length - 1];
            if (looksLikeVideoId(candidate)) return candidate;
          }
          return null;
        }

        function extractListId(loc) {
          var byList = getParam("list", loc.search);
          if (byList) return byList;
          return null;
        }

        var videoId = extractVideoId(window.location);
        var listId = extractListId(window.location);

        if (!videoId) {
          document.title = "YouTube Embed Proxy";
          return;
        }

        document.title = "\u25B6 " + videoId + " - YouTube Embed";
        var messageEl = document.getElementById("message");
        var wrapperEl = document.getElementById("playerWrapper");
        if (messageEl) messageEl.style.display = "none";
        if (wrapperEl) wrapperEl.style.display = "block";

        var start = getParam("start", window.location.search) || getParam("t", window.location.search);
        var startSec = start && /^\d+$/.test(start) ? Number(start) : null;

        var candidateConfigs = [
          { idSuffix: "primary" },
          { idSuffix: "secondary" },
          { idSuffix: "tertiary" },
          { idSuffix: "quaternary" },
          { idSuffix: "quinary" },
          { idSuffix: "senary" },
          { idSuffix: "septenary" },
          { idSuffix: "octonary" },
          { idSuffix: "nonary" },
          { idSuffix: "denary" },
          { idSuffix: "unary" },
          { idSuffix: "binary" },
          // { idSuffix: "nocookie", host: "https://www.youtube-nocookie.com" }
        ];

        function validatePlaybackRate(rate) {
          var numeric = Number(rate);
          if (!Number.isFinite(numeric) || numeric <= 0) return 1;
          return numeric;
        }

        function createYouTubeApiScript() {
          var tag = document.createElement("script");
          tag.src = "https://www.youtube.com/iframe_api";
          var firstScriptTag = document.getElementsByTagName("script")[0];
          firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
        }

        function YouTubePlayerController(options) {
          this.videoId = options.videoId;
          this.listId = options.listId;
          this.startSeconds = options.startSeconds;
          this.wrapperEl = options.wrapperEl;
          this.candidateConfigs = Array.isArray(options.candidateConfigs) && options.candidateConfigs.length
            ? options.candidateConfigs
            : [{ idSuffix: "primary" }];

          this.progressStore = Object.create(null);
          this.pendingRate = null;
          this.lastRequestedRate = null;
          // this.candidates will now hold objects that may or may not have a constructed player/DOM yet
          // { config, ready, failed, player, container, hostId, ... }
          this.candidates = []; 
          this.activeCandidate = null;
          this.progressIntervalId = null;
          this.detectionInterval = 500;
          this.lastAdReloadAt = 0;
          
          this.adReloadCooldownMs = 1000;

          this.resetProgress();
          // Initialize the candidates array structure but don't create DOM/Players yet
          this.setupCandidatesMeta();
        }

        YouTubePlayerController.prototype.resetProgress = function () {
          this.progressStore[this.videoId] = { currentTime: 0, updatedAt: Date.now() };
        };

        YouTubePlayerController.prototype.saveProgress = function (seconds) {
          var sec = Number(seconds);
          if (!Number.isFinite(sec) || sec < 0) sec = 0;
          this.progressStore[this.videoId] = { currentTime: sec, updatedAt: Date.now() };
        };

        YouTubePlayerController.prototype.readProgress = function () {
          var obj = this.progressStore[this.videoId];
          var t = Number(obj && obj.currentTime);
          return Number.isFinite(t) && t >= 0 ? t : 0;
        };

        // Initialize metadata for candidates without creating DOM
        YouTubePlayerController.prototype.setupCandidatesMeta = function () {
          var self = this;
          this.candidates = this.candidateConfigs.map(function (config, index) {
            var suffix = config.idSuffix || "candidate-" + index;
            var hostId = index === 0 ? "player" : "player-" + suffix;
            return {
              index: index,
              config: config,
              hostId: hostId,
              container: null, // Will be created on demand
              player: null,    // Will be created on demand
              ready: false,
              failed: false,
              lastTime: 0,
              initializing: false
            };
          });
        };

        // Initialize only the first player
        YouTubePlayerController.prototype.initPlayers = function () {
            if (this.candidates.length > 0) {
                this.ensureCandidateInitialized(this.candidates[0]);
            }
        };

        // Create DOM and YT.Player for a specific candidate if not already done
        YouTubePlayerController.prototype.ensureCandidateInitialized = function (candidate) {
          if (candidate.player || candidate.initializing || candidate.failed) return;
          
          candidate.initializing = true;

          // 1. Create DOM structure
          var container = document.createElement("div");
          container.className = "player-slot-wrapper";
          container.style.width = "100%";
          container.style.height = "100%";
          container.style.position = "relative";
          container.style.display = "none";

          var host = document.createElement("div");
          host.id = candidate.hostId;
          host.className = "player-slot";
          host.style.width = "100%";
          host.style.height = "100%";

          container.appendChild(host);
          this.wrapperEl.appendChild(container);
          candidate.container = container;

          // 2. Init Player
          if (typeof YT === "undefined" || !YT.Player) {
              candidate.initializing = false;
              return; // Should retry later when API is ready
          }

          var self = this;
          var baseVars = {
            autoplay: 1,
            playsinline: 1,
            rel: 0
          };

          if (this.listId) {
            baseVars.listType = "playlist";
            baseVars.list = this.listId;
          }

          var startSec = this.startSeconds;
          // If we are initializing a backup player mid-playback, try to start at current progress
          if (candidate.index > 0) {
              var currentProg = this.readProgress();
              if (currentProg > 0) startSec = currentProg;
          }

          if (startSec != null) {
            baseVars.start = startSec;
          }

          var vars = Object.assign({}, baseVars, candidate.config.playerVars || {});
            var playerOptions = {
              width: "100%",
              height: "100%",
              videoId: self.videoId,
              playerVars: vars,
              events: {
                onReady: function () { 
                    candidate.initializing = false;
                    self.onCandidateReady(candidate); 
                },
                onStateChange: function (event) { self.onCandidateStateChange(candidate, event); },
                onError: function (event) { 
                    candidate.initializing = false;
                    self.onCandidateError(candidate, event); 
                }
              }
            };

            if (candidate.config.host) {
              playerOptions.host = candidate.config.host;
            }

            candidate.player = new YT.Player(candidate.hostId, playerOptions);
        };

        YouTubePlayerController.prototype.onCandidateReady = function (candidate) {
          candidate.ready = true;
          try { candidate.player.mute(); } catch (_) { /* ignore */ }

          // If this is the very first one or we need a fallback, activate it
          if (!this.activeCandidate) {
            this.activateCandidate(candidate);
          } else if (this.activeCandidate.failed && this.activeCandidate !== candidate) {
             this.activateCandidate(candidate);
          } 
          
          if (this.pendingRate != null) {
            this.applyPlaybackRate(candidate, this.pendingRate);
          }
        };

        YouTubePlayerController.prototype.onCandidateStateChange = function (candidate, event) {
          candidate.state = event.data;
          if (event.data === YT.PlayerState.PLAYING) {
            // If we are actively looking for a working candidate (e.g. current one failed or is ad), switch
            if (!this.activeCandidate || this.activeCandidate === candidate) {
              this.activateCandidate(candidate);
            } else if (this.activeCandidate && (this.activeCandidate.failed)) {
              this.activateCandidate(candidate);
            }
          }
        };

        YouTubePlayerController.prototype.onCandidateError = function (candidate) {
          candidate.failed = true;
          // If the current active one failed, try to find next or create next
          if (this.activeCandidate === candidate) {
            this.switchToNextAvailableCandidate(candidate);
          }
        };

        // Attempts to switch to an existing ready candidate, OR triggers creation of the next one
        YouTubePlayerController.prototype.switchToNextAvailableCandidate = function (currentBadCandidate) {
            // 1. Try to find an already ready candidate
            for (var i = 0; i < this.candidates.length; i++) {
                var c = this.candidates[i];
                if (c !== currentBadCandidate && c.ready && !c.failed && c.player) {
                    this.activateCandidate(c);
                    return;
                }
            }

            // 2. If no ready candidate, find the next uninitialized one and init it
            // We search starting from the current candidate's index + 1
            var nextIndex = (currentBadCandidate.index + 1) % this.candidates.length;
            // Loop once to find the first non-failed, non-initialized one
            for (var k = 0; k < this.candidates.length; k++) {
                var idx = (nextIndex + k) % this.candidates.length;
                var potential = this.candidates[idx];
                if (potential !== currentBadCandidate && !potential.failed && !potential.ready && !potential.initializing) {
                    // Found a candidate to lazy load
                    this.ensureCandidateInitialized(potential);
                    return; 
                }
            }
        };
        
        // Old method kept for compatibility, but logic is now in switchToNextAvailableCandidate mostly
        YouTubePlayerController.prototype.findFallbackCandidate = function (exclude) {
             // This is purely for "is there a ready one NOW"
            for (var i = 0; i < this.candidates.length; i++) {
                var candidate = this.candidates[i];
                if (candidate !== exclude && candidate.ready && !candidate.failed && candidate.player) {
                return candidate;
                }
            }
            return null;
        };

        function setCandidateVisibility(candidate, visible) {
          if (!candidate || !candidate.container) return;
          var displayValue = visible ? "block" : "none";
          candidate.container.style.display = displayValue;
          var iframe = candidate.container.querySelector("iframe");
          if (iframe) iframe.style.display = displayValue;
          var host = candidate.container.querySelector(".player-slot");
          if (host && host !== iframe) host.style.display = displayValue;
        }

        YouTubePlayerController.prototype.activateCandidate = function (candidate) {
          if (!candidate) return;
          var alreadyActive = this.activeCandidate === candidate;
          this.activeCandidate = candidate;

          // Hide others, Show this one
          for (var i = 0; i < this.candidates.length; i++) {
            var entry = this.candidates[i];
            
            // If entry is not initialized, nothing to hide/show
            if (!entry.container) continue;

            var shouldShow = entry === candidate;
            setCandidateVisibility(entry, shouldShow);

            if (!entry.player) continue;
            try {
              if (shouldShow) {
                var activePlayer = entry.player;
                activePlayer.playVideo();
                setTimeout((function (p) {
                  return function () {
                    try { p.unMute(); } catch (_) { /* ignore */ }
                  };
                })(activePlayer), 0);
                if (this.lastRequestedRate != null) {
                  this.applyPlaybackRate(entry, this.lastRequestedRate);
                } else if (this.pendingRate != null) {
                  this.applyPlaybackRate(entry, this.pendingRate);
                }
                this.pendingRate = null;
              } else {
                entry.player.mute();
                entry.player.pauseVideo();
              }
            } catch (_) { /* ignore */ }
          }

          if (!alreadyActive || !this.progressIntervalId) {
            this.startProgressTracking();
          }
        };

        YouTubePlayerController.prototype.applyPlaybackRate = function (candidate, rate) {
          try {
            if (candidate.player && typeof candidate.player.setPlaybackRate === "function") {
              candidate.player.setPlaybackRate(rate);
              return true;
            }
          } catch (_) { /* ignore */ }
          return false;
        };

        YouTubePlayerController.prototype.setPlaybackRate = function (rate) {
          var validated = validatePlaybackRate(rate);
          this.lastRequestedRate = validated;

          if (this.activeCandidate && this.applyPlaybackRate(this.activeCandidate, validated)) {
            this.pendingRate = null;
            return;
          }

          this.pendingRate = validated;
        };

        YouTubePlayerController.prototype.startProgressTracking = function () {
          var self = this;
          this.stopProgressTracking();

          this.progressIntervalId = setInterval(function () {
            var candidate = self.activeCandidate;
            if (!candidate || !candidate.player) return;

            try {
              var player = candidate.player;
              // Safety check: accessing methods on destroyed or unready player
              if (typeof player.getCurrentTime !== "function") return;

              var currentTime = player.getCurrentTime();
              var state = typeof player.getPlayerState === "function" ? player.getPlayerState() : null;
              var data = typeof player.getVideoData === "function" ? player.getVideoData() : null;

              if (Number.isFinite(currentTime)) {
                self.saveProgress(currentTime);
              }

              if (self.isAdPlayback(candidate, state, currentTime, data)) {
                self.handleAdDetected(candidate);
              } else if (Number.isFinite(currentTime)) {
                candidate.lastTime = currentTime;
              }
            } catch (_) { /* ignore */ }
          }, this.detectionInterval);
        };

        YouTubePlayerController.prototype.stopProgressTracking = function () {
          if (this.progressIntervalId) {
            clearInterval(this.progressIntervalId);
            this.progressIntervalId = null;
          }
        };

        YouTubePlayerController.prototype.isAdPlayback = function (candidate, state, currentTime, videoData) {
          if (videoData && videoData.author === "") return true;
          if (state === -1 && Number.isFinite(candidate.lastTime) && Number.isFinite(currentTime) && currentTime !== candidate.lastTime) {
            return true;
          }
          return false;
        };

        YouTubePlayerController.prototype.handleAdDetected = function (candidate) {
          var now = Date.now();
          if (now - this.lastAdReloadAt < this.adReloadCooldownMs) return;
          this.lastAdReloadAt = now;

          // "Ad detected" means we want to switch
          this.switchToNextAvailableCandidate(candidate);
        };

        // This is now used only if we have NO other candidates to switch to
        YouTubePlayerController.prototype.reloadCandidateAtProgress = function (candidate) {
          var resumeAt = this.readProgress();
          candidate.lastTime = resumeAt;
          try {
            if (this.listId) {
              candidate.player.loadPlaylist({ playlistId: this.listId, startIndex: resumeAt });
            } else {
              candidate.player.loadVideoById({ videoId: this.videoId, startSeconds: resumeAt });
            }

            var self = this;
            if (this.lastRequestedRate != null) {
              setTimeout(function () {
                self.applyPlaybackRate(candidate, self.lastRequestedRate);
              }, 500);
            }
          } catch (_) { /* ignore */ }
        };

        YouTubePlayerController.prototype.handleBeforeUnload = function () {
          try {
            var candidate = this.activeCandidate;
            if (candidate && candidate.player && typeof candidate.player.getCurrentTime === "function") {
              var t = candidate.player.getCurrentTime();
              if (Number.isFinite(t)) {
                this.saveProgress(t);
              }
            }
          } catch (_) { /* ignore */ }

          this.stopProgressTracking();
        };

        var controller = new YouTubePlayerController({
          videoId: videoId,
          listId: listId,
          startSeconds: startSec,
          wrapperEl: wrapperEl,
          candidateConfigs: candidateConfigs
        });

        createYouTubeApiScript();

        window.onYouTubeIframeAPIReady = function () {
          controller.initPlayers();

          if (controller.pendingRate != null && controller.activeCandidate) {
            controller.setPlaybackRate(controller.pendingRate);
          }
        };

        window.addEventListener("message", function (event) {
          var data = event.data;
          if (typeof data === "string") {
            try { data = JSON.parse(data); } catch (_) { /* ignore */ }
          }
          if (!data || typeof data !== "object") return;
          if (data.type === "setPlaybackRate") {
            controller.setPlaybackRate(data.value);
          }
        });

        window.addEventListener("beforeunload", function () {
          controller.handleBeforeUnload();
        });
      })();
    </script>
  </body>
</html>
